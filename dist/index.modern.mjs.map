{"version":3,"file":"index.modern.mjs","sources":["../src/queryClientAtom.ts","../src/common.ts","../src/atomsWithQuery.ts","../src/atomsWithInfiniteQuery.ts","../src/atomsWithMutation.ts","../src/atomsWithQueryAsync.ts"],"sourcesContent":["import { QueryClient } from '@tanstack/query-core'\nimport { atom } from 'jotai/vanilla'\n\nexport const queryClientAtom = atom(new QueryClient())\n\nif (process.env.NODE_ENV !== 'production') {\n  queryClientAtom.debugPrivate = true\n}\n","import { QueryClient, isCancelledError } from '@tanstack/query-core'\nimport type { Getter } from 'jotai/vanilla'\nimport { atom } from 'jotai/vanilla'\nimport { atomWithObservable } from 'jotai/vanilla/utils'\n\nexport const createAtoms = <\n  Options,\n  Result extends {\n    isSuccess: boolean\n    isError: boolean\n    data: any\n    error: any\n    dataUpdatedAt?: any\n  },\n  Observer extends {\n    setOptions(options: Options): void\n    getCurrentResult(): Result\n    subscribe(callback: (result: Result) => void): () => void\n  },\n  Action,\n  ActionResult\n>(\n  getOptions: (get: Getter) => Options,\n  getQueryClient: (get: Getter) => QueryClient,\n  createObserver: (client: QueryClient, options: Options) => Observer,\n  handleAction: (\n    action: Action,\n    observer: Observer,\n    refresh: () => void\n  ) => ActionResult\n) => {\n  const observerCacheAtom = atom(() => new WeakMap<QueryClient, Observer>())\n\n  if (process.env.NODE_ENV !== 'production') {\n    observerCacheAtom.debugPrivate = true\n  }\n\n  const refreshAtom = atom(0)\n  if (process.env.NODE_ENV !== 'production') {\n    refreshAtom.debugPrivate = true\n  }\n\n  // This is for a special property to indicate\n  // that it is in the render function.\n  // It's a workaround because we can't use useEffect.\n  const IN_RENDER = Symbol()\n\n  const observerAtom = atom((get) => {\n    get(refreshAtom)\n    const queryClient = getQueryClient(get)\n    const options = getOptions(get)\n    const observerCache = get(observerCacheAtom)\n    let observer = observerCache.get(queryClient)\n    if (observer) {\n      ;(observer as any)[IN_RENDER] = true\n      observer.setOptions(options)\n      delete (observer as any)[IN_RENDER]\n    } else {\n      observer = createObserver(queryClient, options)\n      observerCache.set(queryClient, observer)\n    }\n    return observer\n  })\n\n  if (process.env.NODE_ENV !== 'production') {\n    observerAtom.debugPrivate = true\n  }\n\n  const baseStatusAtom = atom((get) => {\n    const options = getOptions(get) // re-create observable when options change\n    const observer = get(observerAtom)\n    const observable = {\n      subscribe: (arg: { next: (result: Result) => void }) => {\n        const callback = (result: Result) => {\n          const notifyResult = () => arg.next(result)\n          if ((observer as any)[IN_RENDER]) {\n            Promise.resolve().then(notifyResult)\n          } else {\n            notifyResult()\n          }\n        }\n        const unsubscribe = observer.subscribe(callback)\n        const currentResult = observer.getCurrentResult()\n        const optimisticResult = (observer as any).getOptimisticResult?.(\n          options\n        )\n        const freshData =\n          !currentResult?.dataUpdatedAt ||\n          !optimisticResult?.dataUpdatedAt ||\n          currentResult?.dataUpdatedAt >= optimisticResult?.dataUpdatedAt\n            ? currentResult\n            : optimisticResult\n        callback(freshData)\n        return { unsubscribe }\n      },\n    }\n    const resultAtom = atomWithObservable(() => observable, {\n      initialValue: observer.getCurrentResult(),\n    })\n\n    if (process.env.NODE_ENV !== 'production') {\n      resultAtom.debugPrivate = true\n    }\n\n    return resultAtom\n  })\n\n  if (process.env.NODE_ENV !== 'production') {\n    baseStatusAtom.debugPrivate = true\n  }\n\n  const statusAtom = atom(\n    (get) => {\n      const resultAtom = get(baseStatusAtom)\n      return get(resultAtom)\n    },\n    (get, set, action: Action) => {\n      const observer = get(observerAtom)\n      const refresh = () => {\n        const queryClient = getQueryClient(get)\n        const observerCache = get(observerCacheAtom)\n        observerCache.delete(queryClient)\n        set(refreshAtom, (c) => c + 1)\n      }\n      return handleAction(action, observer, refresh)\n    }\n  )\n\n  const baseDataAtom = atom((get) => {\n    const options = getOptions(get) // re-create observable when options change\n    const observer = get(observerAtom)\n    const observable = {\n      subscribe: (arg: { next: (result: Result) => void }) => {\n        const callback = (result: Result) => {\n          if (\n            (result.isSuccess && result.data !== undefined) ||\n            (result.isError && !isCancelledError(result.error))\n          ) {\n            const notifyResult = () => arg.next(result)\n            if ((observer as any)[IN_RENDER]) {\n              Promise.resolve().then(notifyResult)\n            } else {\n              notifyResult()\n            }\n          }\n        }\n        const unsubscribe = observer.subscribe(callback)\n        const currentResult = observer.getCurrentResult()\n        const optimisticResult = (observer as any).getOptimisticResult?.(\n          options\n        )\n        const freshData =\n          !currentResult?.dataUpdatedAt ||\n          !optimisticResult?.dataUpdatedAt ||\n          currentResult?.dataUpdatedAt >= optimisticResult?.dataUpdatedAt\n            ? currentResult\n            : optimisticResult\n        callback(freshData)\n\n        return { unsubscribe }\n      },\n    }\n    const resultAtom = atomWithObservable(() => observable)\n\n    if (process.env.NODE_ENV !== 'production') {\n      resultAtom.debugPrivate = true\n    }\n\n    return resultAtom\n  })\n\n  if (process.env.NODE_ENV !== 'production') {\n    baseDataAtom.debugPrivate = true\n  }\n\n  const returnResultData = (result: Result) => {\n    if (result.error) {\n      throw result.error\n    }\n    return result.data\n  }\n\n  const dataAtom = atom(\n    (get) => {\n      const resultAtom = get(baseDataAtom)\n      const result = get(resultAtom)\n      if (result instanceof Promise) {\n        return result.then(returnResultData)\n      }\n      return returnResultData(result)\n    },\n    (_get, set, action: Action) => set(statusAtom, action)\n  )\n\n  return [dataAtom, statusAtom] as const\n}\n\nexport const createAsyncAtoms = <\n  Options,\n  Result extends {\n    isSuccess: boolean\n    isError: boolean\n    data: any\n    error: any\n  },\n  Observer extends {\n    setOptions(options: Options): void\n    getCurrentResult(): Result\n    subscribe(callback: (result: Result) => void): () => void\n  },\n  Action,\n  ActionResult\n>(\n  getOptions: (get: Getter) => Promise<Options>,\n  getQueryClient: (get: Getter) => QueryClient,\n  createObserver: (client: QueryClient, options: Options) => Observer,\n  handleAction: (\n    action: Action,\n    observer: Observer,\n    refresh: () => void\n  ) => Promise<ActionResult>\n) => {\n  const observerCacheAtom = atom(() => new WeakMap<QueryClient, Observer>())\n\n  if (process.env.NODE_ENV !== 'production') {\n    observerCacheAtom.debugPrivate = true\n  }\n\n  const refreshAtom = atom(0)\n  if (process.env.NODE_ENV !== 'production') {\n    refreshAtom.debugPrivate = true\n  }\n\n  // This is for a special property to indicate\n  // that it is in the render function.\n  // It's a workaround because we can't use useEffect.\n  const IN_RENDER = Symbol()\n\n  const observerAtom = atom(async (get) => {\n    get(refreshAtom)\n    const options = await getOptions(get)\n    const queryClient = getQueryClient(get)\n    const observerCache = get(observerCacheAtom)\n    let observer = observerCache.get(queryClient)\n    if (observer) {\n      ;(observer as any)[IN_RENDER] = true\n      observer.setOptions(options)\n      delete (observer as any)[IN_RENDER]\n    } else {\n      observer = createObserver(queryClient, options)\n      observerCache.set(queryClient, observer)\n    }\n    return observer\n  })\n\n  if (process.env.NODE_ENV !== 'production') {\n    observerAtom.debugPrivate = true\n  }\n\n  const baseStatusAtom = atom(async (get) => {\n    const observer = await get(observerAtom)\n    const observable = {\n      subscribe: (arg: { next: (result: Result) => void }) => {\n        const callback = (result: Result) => {\n          const notifyResult = () => arg.next(result)\n          if ((observer as any)[IN_RENDER]) {\n            Promise.resolve().then(notifyResult)\n          } else {\n            notifyResult()\n          }\n        }\n        const unsubscribe = observer.subscribe(callback)\n        callback(observer.getCurrentResult())\n        return { unsubscribe }\n      },\n    }\n    const resultAtom = atomWithObservable(() => observable, {\n      initialValue: observer.getCurrentResult(),\n    })\n\n    if (process.env.NODE_ENV !== 'production') {\n      resultAtom.debugPrivate = true\n    }\n\n    return resultAtom\n  })\n\n  if (process.env.NODE_ENV !== 'production') {\n    baseStatusAtom.debugPrivate = true\n  }\n\n  const statusAtom = atom(\n    async (get) => {\n      const resultAtom = await get(baseStatusAtom)\n      return get(resultAtom)\n    },\n    async (get, set, action: Action) => {\n      const observer = await get(observerAtom)\n      const refresh = () => {\n        const queryClient = getQueryClient(get)\n        const observerCache = get(observerCacheAtom)\n        observerCache.delete(queryClient)\n        set(refreshAtom, (c) => c + 1)\n      }\n      return await handleAction(action, observer, refresh)\n    }\n  )\n\n  const baseDataAtom = atom(async (get) => {\n    getOptions(get) // re-create observable when options change\n    const observer = await get(observerAtom)\n    const observable = {\n      subscribe: (arg: { next: (result: Result) => void }) => {\n        const callback = (result: Result) => {\n          if (\n            (result.isSuccess && result.data !== undefined) ||\n            (result.isError && !isCancelledError(result.error))\n          ) {\n            const notifyResult = () => arg.next(result)\n            if ((observer as any)[IN_RENDER]) {\n              Promise.resolve().then(notifyResult)\n            } else {\n              notifyResult()\n            }\n          }\n        }\n        const unsubscribe = observer.subscribe(callback)\n        callback(observer.getCurrentResult())\n        return { unsubscribe }\n      },\n    }\n    const resultAtom = atomWithObservable(() => observable)\n\n    if (process.env.NODE_ENV !== 'production') {\n      resultAtom.debugPrivate = true\n    }\n\n    return resultAtom\n  })\n\n  if (process.env.NODE_ENV !== 'production') {\n    baseDataAtom.debugPrivate = true\n  }\n\n  const returnResultData = (result: Result) => {\n    if (result.error) {\n      throw result.error\n    }\n    return result.data\n  }\n\n  const dataAtom = atom(\n    async (get) => {\n      const resultAtom = await get(baseDataAtom)\n      const result = await get(resultAtom)\n      if (result instanceof Promise) {\n        return result.then(returnResultData)\n      }\n      return await returnResultData(result)\n    },\n    (_get, set, action: Action) => set(statusAtom, action)\n  )\n\n  return [dataAtom, statusAtom] as const\n}\n","import { QueryClient, QueryObserver } from '@tanstack/query-core'\nimport type {\n  QueryKey,\n  QueryObserverOptions,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { Getter, WritableAtom } from 'jotai/vanilla'\nimport { createAtoms } from './common'\nimport { queryClientAtom } from './queryClientAtom'\n\ntype Action = {\n  type: 'refetch'\n  force?: boolean\n  options?: Parameters<QueryObserver['refetch']>[0]\n}\n\nexport function atomsWithQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey\n>(\n  getOptions: (\n    get: Getter\n  ) => QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n): readonly [\n  dataAtom: WritableAtom<\n    TData | Promise<TData>,\n    [Action],\n    Promise<QueryObserverResult<TData, TError>> | undefined\n  >,\n  statusAtom: WritableAtom<\n    QueryObserverResult<TData, TError>,\n    [Action],\n    Promise<QueryObserverResult<TData, TError>> | undefined\n  >\n] {\n  return createAtoms(\n    getOptions,\n    getQueryClient,\n    (client, options) => new QueryObserver(client, options),\n    (action, observer, refresh) => {\n      if (action.type === 'refetch') {\n        if (action.force) {\n          observer.remove()\n          refresh()\n          return\n        }\n        return observer.refetch(action.options)\n      }\n    }\n  )\n}\n","import { InfiniteQueryObserver, QueryClient } from '@tanstack/query-core'\nimport type {\n  InfiniteData,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n  QueryKey,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { Getter, WritableAtom } from 'jotai/vanilla'\nimport { createAtoms } from './common'\nimport { queryClientAtom } from './queryClientAtom'\n\ntype Action =\n  | {\n      type: 'refetch'\n      force?: boolean\n      options?: Parameters<InfiniteQueryObserver['refetch']>[0]\n    }\n  | { type: 'fetchNextPage' }\n  | { type: 'fetchPreviousPage' }\n\nexport function atomsWithInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey\n>(\n  getOptions: (\n    get: Getter\n  ) => InfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n): readonly [\n  dataAtom: WritableAtom<\n    InfiniteData<TData> | Promise<InfiniteData<TData>>,\n    [Action],\n    Promise<QueryObserverResult<InfiniteData<TData>, TError>> | undefined\n  >,\n  statusAtom: WritableAtom<\n    InfiniteQueryObserverResult<TData, TError>,\n    [Action],\n    Promise<QueryObserverResult<InfiniteData<TData>, TError>> | undefined\n  >\n] {\n  return createAtoms(\n    getOptions,\n    getQueryClient,\n    (client, options) => new InfiniteQueryObserver(client, options),\n    (action, observer, refresh) => {\n      if (action.type === 'refetch') {\n        if (action.force) {\n          observer.remove()\n          refresh()\n          return\n        }\n        return observer.refetch(action.options)\n      }\n      if (action.type === 'fetchNextPage') {\n        return observer.fetchNextPage()\n      }\n      if (action.type === 'fetchPreviousPage') {\n        return observer.fetchPreviousPage()\n      }\n    }\n  )\n}\n","import { MutationObserver, QueryClient } from '@tanstack/query-core'\nimport type {\n  MutateOptions,\n  MutationObserverOptions,\n  MutationObserverResult,\n} from '@tanstack/query-core'\nimport type { Getter, WritableAtom } from 'jotai/vanilla'\nimport { createAtoms } from './common'\nimport { queryClientAtom } from './queryClientAtom'\n\ntype Action<TData, TError, TVariables, TContext> = [\n  variables: TVariables,\n  options?: MutateOptions<TData, TError, TVariables, TContext>\n]\n\nexport function atomsWithMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  getOptions: (\n    get: Getter\n  ) => MutationObserverOptions<TData, TError, TVariables, TContext>,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n): readonly [\n  dataAtom: WritableAtom<\n    TData | Promise<TData>,\n    [Action<TData, TError, TVariables, TContext>],\n    Promise<TData>\n  >,\n  statusAtom: WritableAtom<\n    MutationObserverResult<TData, TError, TVariables, TContext>,\n    [Action<TData, TError, TVariables, TContext>],\n    Promise<TData>\n  >\n] {\n  return createAtoms(\n    getOptions,\n    getQueryClient,\n    (client, options) => new MutationObserver(client, options),\n    (action, observer) => observer.mutate(...action)\n  )\n}\n","import type {\n  QueryKey,\n  QueryObserverOptions,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport { QueryClient, QueryObserver } from '@tanstack/query-core'\nimport type { Getter, WritableAtom } from 'jotai'\nimport { createAsyncAtoms } from './common'\nimport { queryClientAtom } from './queryClientAtom'\n\ntype Action = {\n  type: 'refetch'\n  force?: boolean\n  options?: Parameters<QueryObserver['refetch']>[0]\n}\n\nexport function atomsWithQueryAsync<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey\n>(\n  getOptions: (\n    get: Getter\n  ) => Promise<\n    QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n  >,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n): readonly [\n  dataAtom: WritableAtom<\n    Promise<TData>,\n    [Action],\n    Promise<QueryObserverResult<TData, TError>> | undefined\n  >,\n  statusAtom: WritableAtom<\n    QueryObserverResult<TData, TError>,\n    [Action],\n    Promise<QueryObserverResult<TData, TError>> | undefined\n  >\n] {\n  return createAsyncAtoms(\n    getOptions,\n    getQueryClient,\n    (client, options) => new QueryObserver(client, options),\n    async (action: Action, observer, refresh) => {\n      if (action.type === 'refetch') {\n        if (action.force) {\n          observer.remove()\n          refresh()\n          return\n        }\n        return await observer.refetch(action.options)\n      }\n    }\n  ) as any\n}\n"],"names":["queryClientAtom","atom","QueryClient","process","env","NODE_ENV","debugPrivate","createAtoms","getOptions","getQueryClient","createObserver","handleAction","observerCacheAtom","WeakMap","refreshAtom","IN_RENDER","Symbol","observerAtom","get","queryClient","options","observerCache","observer","setOptions","set","baseStatusAtom","observable","subscribe","arg","callback","result","notifyResult","next","Promise","resolve","then","unsubscribe","currentResult","getCurrentResult","optimisticResult","getOptimisticResult","dataUpdatedAt","resultAtom","atomWithObservable","initialValue","statusAtom","action","refresh","delete","c","baseDataAtom","isSuccess","undefined","data","isError","isCancelledError","error","returnResultData","_get","atomsWithQuery","client","QueryObserver","type","force","remove","refetch","atomsWithInfiniteQuery","InfiniteQueryObserver","fetchNextPage","fetchPreviousPage","atomsWithMutation","MutationObserver","mutate","atomsWithQueryAsync","createAsyncAtoms","async"],"mappings":"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"}