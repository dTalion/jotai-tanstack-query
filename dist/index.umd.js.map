{"version":3,"file":"index.umd.js","sources":["../src/queryClientAtom.ts","../src/common.ts","../src/atomsWithInfiniteQuery.ts","../src/atomsWithMutation.ts","../src/atomsWithQuery.ts","../src/atomsWithQueryAsync.ts"],"sourcesContent":["import { QueryClient } from '@tanstack/query-core'\nimport { atom } from 'jotai/vanilla'\n\nexport const queryClientAtom = atom(new QueryClient())\n\nif (process.env.NODE_ENV !== 'production') {\n  queryClientAtom.debugPrivate = true\n}\n","import { QueryClient, isCancelledError } from '@tanstack/query-core'\nimport type { Getter } from 'jotai/vanilla'\nimport { atom } from 'jotai/vanilla'\nimport { atomWithObservable } from 'jotai/vanilla/utils'\n\nexport const createAtoms = <\n  Options,\n  Result extends {\n    isSuccess: boolean\n    isError: boolean\n    data: any\n    error: any\n    dataUpdatedAt?: any\n  },\n  Observer extends {\n    setOptions(options: Options): void\n    getCurrentResult(): Result\n    subscribe(callback: (result: Result) => void): () => void\n  },\n  Action,\n  ActionResult\n>(\n  getOptions: (get: Getter) => Options,\n  getQueryClient: (get: Getter) => QueryClient,\n  createObserver: (client: QueryClient, options: Options) => Observer,\n  handleAction: (\n    action: Action,\n    observer: Observer,\n    refresh: () => void\n  ) => ActionResult\n) => {\n  const observerCacheAtom = atom(() => new WeakMap<QueryClient, Observer>())\n\n  if (process.env.NODE_ENV !== 'production') {\n    observerCacheAtom.debugPrivate = true\n  }\n\n  const refreshAtom = atom(0)\n  if (process.env.NODE_ENV !== 'production') {\n    refreshAtom.debugPrivate = true\n  }\n\n  // This is for a special property to indicate\n  // that it is in the render function.\n  // It's a workaround because we can't use useEffect.\n  const IN_RENDER = Symbol()\n\n  const observerAtom = atom((get) => {\n    get(refreshAtom)\n    const queryClient = getQueryClient(get)\n    const options = getOptions(get)\n    const observerCache = get(observerCacheAtom)\n    let observer = observerCache.get(queryClient)\n    if (observer) {\n      ;(observer as any)[IN_RENDER] = true\n      observer.setOptions(options)\n      delete (observer as any)[IN_RENDER]\n    } else {\n      observer = createObserver(queryClient, options)\n      observerCache.set(queryClient, observer)\n    }\n    return observer\n  })\n\n  if (process.env.NODE_ENV !== 'production') {\n    observerAtom.debugPrivate = true\n  }\n\n  const baseStatusAtom = atom((get) => {\n    const options = getOptions(get) // re-create observable when options change\n    const observer = get(observerAtom)\n    const observable = {\n      subscribe: (arg: { next: (result: Result) => void }) => {\n        const callback = (result: Result) => {\n          const notifyResult = () => arg.next(result)\n          if ((observer as any)[IN_RENDER]) {\n            Promise.resolve().then(notifyResult)\n          } else {\n            notifyResult()\n          }\n        }\n        const unsubscribe = observer.subscribe(callback)\n        const currentResult = observer.getCurrentResult()\n        const optimisticResult = (observer as any).getOptimisticResult?.(\n          options\n        )\n        const freshData =\n          !currentResult?.dataUpdatedAt ||\n          !optimisticResult?.dataUpdatedAt ||\n          currentResult?.dataUpdatedAt >= optimisticResult?.dataUpdatedAt\n            ? currentResult\n            : optimisticResult\n        callback(freshData)\n        return { unsubscribe }\n      },\n    }\n    const resultAtom = atomWithObservable(() => observable, {\n      initialValue: observer.getCurrentResult(),\n    })\n\n    if (process.env.NODE_ENV !== 'production') {\n      resultAtom.debugPrivate = true\n    }\n\n    return resultAtom\n  })\n\n  if (process.env.NODE_ENV !== 'production') {\n    baseStatusAtom.debugPrivate = true\n  }\n\n  const statusAtom = atom(\n    (get) => {\n      const resultAtom = get(baseStatusAtom)\n      return get(resultAtom)\n    },\n    (get, set, action: Action) => {\n      const observer = get(observerAtom)\n      const refresh = () => {\n        const queryClient = getQueryClient(get)\n        const observerCache = get(observerCacheAtom)\n        observerCache.delete(queryClient)\n        set(refreshAtom, (c) => c + 1)\n      }\n      return handleAction(action, observer, refresh)\n    }\n  )\n\n  const baseDataAtom = atom((get) => {\n    const options = getOptions(get) // re-create observable when options change\n    const observer = get(observerAtom)\n    const observable = {\n      subscribe: (arg: { next: (result: Result) => void }) => {\n        const callback = (result: Result) => {\n          if (\n            (result.isSuccess && result.data !== undefined) ||\n            (result.isError && !isCancelledError(result.error))\n          ) {\n            const notifyResult = () => arg.next(result)\n            if ((observer as any)[IN_RENDER]) {\n              Promise.resolve().then(notifyResult)\n            } else {\n              notifyResult()\n            }\n          }\n        }\n        const unsubscribe = observer.subscribe(callback)\n        const currentResult = observer.getCurrentResult()\n        const optimisticResult = (observer as any).getOptimisticResult?.(\n          options\n        )\n        const freshData =\n          !currentResult?.dataUpdatedAt ||\n          !optimisticResult?.dataUpdatedAt ||\n          currentResult?.dataUpdatedAt >= optimisticResult?.dataUpdatedAt\n            ? currentResult\n            : optimisticResult\n        callback(freshData)\n\n        return { unsubscribe }\n      },\n    }\n    const resultAtom = atomWithObservable(() => observable)\n\n    if (process.env.NODE_ENV !== 'production') {\n      resultAtom.debugPrivate = true\n    }\n\n    return resultAtom\n  })\n\n  if (process.env.NODE_ENV !== 'production') {\n    baseDataAtom.debugPrivate = true\n  }\n\n  const returnResultData = (result: Result) => {\n    if (result.error) {\n      throw result.error\n    }\n    return result.data\n  }\n\n  const dataAtom = atom(\n    (get) => {\n      const resultAtom = get(baseDataAtom)\n      const result = get(resultAtom)\n      if (result instanceof Promise) {\n        return result.then(returnResultData)\n      }\n      return returnResultData(result)\n    },\n    (_get, set, action: Action) => set(statusAtom, action)\n  )\n\n  return [dataAtom, statusAtom] as const\n}\n\nexport const createAsyncAtoms = <\n  Options,\n  Result extends {\n    isSuccess: boolean\n    isError: boolean\n    data: any\n    error: any\n  },\n  Observer extends {\n    setOptions(options: Options): void\n    getCurrentResult(): Result\n    subscribe(callback: (result: Result) => void): () => void\n  },\n  Action,\n  ActionResult\n>(\n  getOptions: (get: Getter) => Promise<Options>,\n  getQueryClient: (get: Getter) => QueryClient,\n  createObserver: (client: QueryClient, options: Options) => Observer,\n  handleAction: (\n    action: Action,\n    observer: Observer,\n    refresh: () => void\n  ) => Promise<ActionResult>\n) => {\n  const observerCacheAtom = atom(() => new WeakMap<QueryClient, Observer>())\n\n  if (process.env.NODE_ENV !== 'production') {\n    observerCacheAtom.debugPrivate = true\n  }\n\n  const refreshAtom = atom(0)\n  if (process.env.NODE_ENV !== 'production') {\n    refreshAtom.debugPrivate = true\n  }\n\n  // This is for a special property to indicate\n  // that it is in the render function.\n  // It's a workaround because we can't use useEffect.\n  const IN_RENDER = Symbol()\n\n  const observerAtom = atom(async (get) => {\n    get(refreshAtom)\n    const options = await getOptions(get)\n    const queryClient = getQueryClient(get)\n    const observerCache = get(observerCacheAtom)\n    let observer = observerCache.get(queryClient)\n    if (observer) {\n      ;(observer as any)[IN_RENDER] = true\n      observer.setOptions(options)\n      delete (observer as any)[IN_RENDER]\n    } else {\n      observer = createObserver(queryClient, options)\n      observerCache.set(queryClient, observer)\n    }\n    return observer\n  })\n\n  if (process.env.NODE_ENV !== 'production') {\n    observerAtom.debugPrivate = true\n  }\n\n  const baseStatusAtom = atom(async (get) => {\n    const observer = await get(observerAtom)\n    const observable = {\n      subscribe: (arg: { next: (result: Result) => void }) => {\n        const callback = (result: Result) => {\n          const notifyResult = () => arg.next(result)\n          if ((observer as any)[IN_RENDER]) {\n            Promise.resolve().then(notifyResult)\n          } else {\n            notifyResult()\n          }\n        }\n        const unsubscribe = observer.subscribe(callback)\n        callback(observer.getCurrentResult())\n        return { unsubscribe }\n      },\n    }\n    const resultAtom = atomWithObservable(() => observable, {\n      initialValue: observer.getCurrentResult(),\n    })\n\n    if (process.env.NODE_ENV !== 'production') {\n      resultAtom.debugPrivate = true\n    }\n\n    return resultAtom\n  })\n\n  if (process.env.NODE_ENV !== 'production') {\n    baseStatusAtom.debugPrivate = true\n  }\n\n  const statusAtom = atom(\n    async (get) => {\n      const resultAtom = await get(baseStatusAtom)\n      return get(resultAtom)\n    },\n    async (get, set, action: Action) => {\n      const observer = await get(observerAtom)\n      const refresh = () => {\n        const queryClient = getQueryClient(get)\n        const observerCache = get(observerCacheAtom)\n        observerCache.delete(queryClient)\n        set(refreshAtom, (c) => c + 1)\n      }\n      return await handleAction(action, observer, refresh)\n    }\n  )\n\n  const baseDataAtom = atom(async (get) => {\n    getOptions(get) // re-create observable when options change\n    const observer = await get(observerAtom)\n    const observable = {\n      subscribe: (arg: { next: (result: Result) => void }) => {\n        const callback = (result: Result) => {\n          if (\n            (result.isSuccess && result.data !== undefined) ||\n            (result.isError && !isCancelledError(result.error))\n          ) {\n            const notifyResult = () => arg.next(result)\n            if ((observer as any)[IN_RENDER]) {\n              Promise.resolve().then(notifyResult)\n            } else {\n              notifyResult()\n            }\n          }\n        }\n        const unsubscribe = observer.subscribe(callback)\n        callback(observer.getCurrentResult())\n        return { unsubscribe }\n      },\n    }\n    const resultAtom = atomWithObservable(() => observable)\n\n    if (process.env.NODE_ENV !== 'production') {\n      resultAtom.debugPrivate = true\n    }\n\n    return resultAtom\n  })\n\n  if (process.env.NODE_ENV !== 'production') {\n    baseDataAtom.debugPrivate = true\n  }\n\n  const returnResultData = (result: Result) => {\n    if (result.error) {\n      throw result.error\n    }\n    return result.data\n  }\n\n  const dataAtom = atom(\n    async (get) => {\n      const resultAtom = await get(baseDataAtom)\n      const result = await get(resultAtom)\n      if (result instanceof Promise) {\n        return result.then(returnResultData)\n      }\n      return await returnResultData(result)\n    },\n    (_get, set, action: Action) => set(statusAtom, action)\n  )\n\n  return [dataAtom, statusAtom] as const\n}\n","import { InfiniteQueryObserver, QueryClient } from '@tanstack/query-core'\nimport type {\n  InfiniteData,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n  QueryKey,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { Getter, WritableAtom } from 'jotai/vanilla'\nimport { createAtoms } from './common'\nimport { queryClientAtom } from './queryClientAtom'\n\ntype Action =\n  | {\n      type: 'refetch'\n      force?: boolean\n      options?: Parameters<InfiniteQueryObserver['refetch']>[0]\n    }\n  | { type: 'fetchNextPage' }\n  | { type: 'fetchPreviousPage' }\n\nexport function atomsWithInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey\n>(\n  getOptions: (\n    get: Getter\n  ) => InfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n): readonly [\n  dataAtom: WritableAtom<\n    InfiniteData<TData> | Promise<InfiniteData<TData>>,\n    [Action],\n    Promise<QueryObserverResult<InfiniteData<TData>, TError>> | undefined\n  >,\n  statusAtom: WritableAtom<\n    InfiniteQueryObserverResult<TData, TError>,\n    [Action],\n    Promise<QueryObserverResult<InfiniteData<TData>, TError>> | undefined\n  >\n] {\n  return createAtoms(\n    getOptions,\n    getQueryClient,\n    (client, options) => new InfiniteQueryObserver(client, options),\n    (action, observer, refresh) => {\n      if (action.type === 'refetch') {\n        if (action.force) {\n          observer.remove()\n          refresh()\n          return\n        }\n        return observer.refetch(action.options)\n      }\n      if (action.type === 'fetchNextPage') {\n        return observer.fetchNextPage()\n      }\n      if (action.type === 'fetchPreviousPage') {\n        return observer.fetchPreviousPage()\n      }\n    }\n  )\n}\n","import { MutationObserver, QueryClient } from '@tanstack/query-core'\nimport type {\n  MutateOptions,\n  MutationObserverOptions,\n  MutationObserverResult,\n} from '@tanstack/query-core'\nimport type { Getter, WritableAtom } from 'jotai/vanilla'\nimport { createAtoms } from './common'\nimport { queryClientAtom } from './queryClientAtom'\n\ntype Action<TData, TError, TVariables, TContext> = [\n  variables: TVariables,\n  options?: MutateOptions<TData, TError, TVariables, TContext>\n]\n\nexport function atomsWithMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  getOptions: (\n    get: Getter\n  ) => MutationObserverOptions<TData, TError, TVariables, TContext>,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n): readonly [\n  dataAtom: WritableAtom<\n    TData | Promise<TData>,\n    [Action<TData, TError, TVariables, TContext>],\n    Promise<TData>\n  >,\n  statusAtom: WritableAtom<\n    MutationObserverResult<TData, TError, TVariables, TContext>,\n    [Action<TData, TError, TVariables, TContext>],\n    Promise<TData>\n  >\n] {\n  return createAtoms(\n    getOptions,\n    getQueryClient,\n    (client, options) => new MutationObserver(client, options),\n    (action, observer) => observer.mutate(...action)\n  )\n}\n","import { QueryClient, QueryObserver } from '@tanstack/query-core'\nimport type {\n  QueryKey,\n  QueryObserverOptions,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { Getter, WritableAtom } from 'jotai/vanilla'\nimport { createAtoms } from './common'\nimport { queryClientAtom } from './queryClientAtom'\n\ntype Action = {\n  type: 'refetch'\n  force?: boolean\n  options?: Parameters<QueryObserver['refetch']>[0]\n}\n\nexport function atomsWithQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey\n>(\n  getOptions: (\n    get: Getter\n  ) => QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n): readonly [\n  dataAtom: WritableAtom<\n    TData | Promise<TData>,\n    [Action],\n    Promise<QueryObserverResult<TData, TError>> | undefined\n  >,\n  statusAtom: WritableAtom<\n    QueryObserverResult<TData, TError>,\n    [Action],\n    Promise<QueryObserverResult<TData, TError>> | undefined\n  >\n] {\n  return createAtoms(\n    getOptions,\n    getQueryClient,\n    (client, options) => new QueryObserver(client, options),\n    (action, observer, refresh) => {\n      if (action.type === 'refetch') {\n        if (action.force) {\n          observer.remove()\n          refresh()\n          return\n        }\n        return observer.refetch(action.options)\n      }\n    }\n  )\n}\n","import type {\n  QueryKey,\n  QueryObserverOptions,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport { QueryClient, QueryObserver } from '@tanstack/query-core'\nimport type { Getter, WritableAtom } from 'jotai'\nimport { createAsyncAtoms } from './common'\nimport { queryClientAtom } from './queryClientAtom'\n\ntype Action = {\n  type: 'refetch'\n  force?: boolean\n  options?: Parameters<QueryObserver['refetch']>[0]\n}\n\nexport function atomsWithQueryAsync<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey\n>(\n  getOptions: (\n    get: Getter\n  ) => Promise<\n    QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n  >,\n  getQueryClient: (get: Getter) => QueryClient = (get) => get(queryClientAtom)\n): readonly [\n  dataAtom: WritableAtom<\n    Promise<TData>,\n    [Action],\n    Promise<QueryObserverResult<TData, TError>> | undefined\n  >,\n  statusAtom: WritableAtom<\n    QueryObserverResult<TData, TError>,\n    [Action],\n    Promise<QueryObserverResult<TData, TError>> | undefined\n  >\n] {\n  return createAsyncAtoms(\n    getOptions,\n    getQueryClient,\n    (client, options) => new QueryObserver(client, options),\n    async (action: Action, observer, refresh) => {\n      if (action.type === 'refetch') {\n        if (action.force) {\n          observer.remove()\n          refresh()\n          return\n        }\n        return await observer.refetch(action.options)\n      }\n    }\n  ) as any\n}\n"],"names":["queryClientAtom","atom","QueryClient","process","env","NODE_ENV","debugPrivate","createAtoms","getOptions","getQueryClient","createObserver","handleAction","observerCacheAtom","WeakMap","refreshAtom","IN_RENDER","Symbol","observerAtom","get","queryClient","options","observerCache","observer","setOptions","set","baseStatusAtom","observable","subscribe","arg","callback","result","notifyResult","next","Promise","resolve","then","unsubscribe","currentResult","getCurrentResult","optimisticResult","getOptimisticResult","dataUpdatedAt","resultAtom","atomWithObservable","initialValue","statusAtom","action","c","baseDataAtom","isSuccess","undefined","data","isError","isCancelledError","error","returnResultData","_get","client","InfiniteQueryObserver","refresh","type","force","remove","refetch","fetchNextPage","fetchPreviousPage","MutationObserver","mutate","apply","QueryObserver","e","reject","createAsyncAtoms"],"mappings":"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"}